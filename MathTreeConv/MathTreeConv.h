#include<iostream>
#include<string>
#include<string.h>
#include<vector>
using namespace std;
enum nodeType{Unknown,Var,Num,Plus,Minus,Mul,Div,Pow,SubTree};


/**
* @brief Класс, представляющий узел дерева разбора математического выражения
*/
class Node
{
private:
	nodeType type; /**< Тип узла */
	float value; /**< Значение числа(если тип узла - число) */
	string name; /**< Имя переменной(если тип узла - переменная), Строковое представление числа(если тип узла - число) */
	Node* left, * right; /**< Ссылки на потомков узла */
public:
	/*!
	* Конструктор узла дерева по умолчанию
	*/
	Node() :type(Unknown), left(NULL), right(NULL) {}

	/*!
	* Конструктор узла дерева соответствующего введёному типу
	* \param[in] Type - тип создаваемого узла
	*/
	Node(nodeType Type) :type(Type), left(NULL), right(NULL) {}

	/*!
	* Конструктор узла дерева типа "Число"
	* \param[in] f - значение числа
	* \param[in] s - строковое представление чимла
	*/
	Node(float f, string s) :type(Num), value(f), name(s) {}

	/*!
	* Конструктор копирования узла
	* \param[in] n - указатель на оригинальный узел
	*/
	Node(Node* n);

	/*!
	*  Преобразует дерево развбора математического выражения в запись в виде обратной польской нотации
	* \return - последовательность подстрок представляющая запись математического выражения
	*/
	vector<string> turnTreeToStringVector();

	/*!
	* Преобразует запись в виде обратной польской в дерево разбора математического выражения
	* \return - полученное дерево
	* \throw - ошибка, связанная с некоректными входными данными
	*/
	static Node* turnStringVectorToTree(vector<string> input);

	/*!
	* Преобразует кортеж из подстрок вида (оператор, аргумент, аругмент) в поддерево
	* \param[in] triple - входной кортеж
	* \return - полученное поддерево
	* \throw - ошибка возникшая при создании поддерева
	*/
	static Node* turnTripleToNode(vector<string> triple);

	/*!
	* Обновление узла в соответствии с определённым шаблоном
	* \return - флаг обновления узла (да - узел обновлён, нет - узел не обновлён)
	*/
	bool updateNode();
	
	/*!
	* Возвращает тип узла
	* \return - тип узла
	*/
	nodeType getType()const;

	/*!
	* Возвращает указатель на левого потомка
	* \return - указатель на левого потомка
	*/
	Node* getLeft()const;

	/*!
	* Возвращает указатель на правого потомка
	* \return - указатель на правого потомка
	*/
	Node* getRight()const;
};

/**
* \brief Считывает запись математического выражения (в виде последовательности подстрок) из файла
* \param[in] link - адрес считываемого файла
* \return - полученная последовательность подстрок
* \throw - ошибка при считывании файла
*/
vector<string> readSequence(string link);

/*!
* \Записывает математическое выражение (в виде последовательности подстрок) в файл
* \param[in] link - адрес файла для записи
* \param[in] output - записываемая последовательность подстрок
* \throw - ошибка при записи в файл
*/
void writeSequence(string link, vector<string> output);

/*!
* \Проверяем соотвтествие введёного кортежа виду (оператор, аргумент, аргумент)
* \param[in] input - тестируемый кортеж
* \return - соответствует ли кортеж виду (оператор, аргумент, аргумент)
*/
bool isCorrectTriple(vector<string> input);

/*!
* \Добавляет поддерево в массив поддеревьев
* \param[in] input - добавляемое поддерево
* \return - индекс добавленного дерева в массиве
*/
string addSubTree(Node* input);

/*!
* \Ищет поддерево в массиве
* \param[in] - индекс поддерева в массиве
* \return - указатель на корень найденного поддерева (0 - если поддерево не найдено)
*/
Node* findSubTree(string input);

/*!
* \Определяем тип узла соответствующий введённой подстроке
* \param[in] input - определяемая подстрока
* \return - тип узла
* \throw - ошибка, если входные данные не корректны
*/
nodeType defNodeType(string input);

/*!
* \Очищает список поддеревьев
*/
void clearForest();